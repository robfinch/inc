# FTA Bus

## Overview
FTA bus is an asynchronous bus used by me (Finitron) mainly as a system-on-chip bus to interface bus masters and slaves together. It evolved from the 'WISHBONE' bus.
The bus is split into request and response parts. Bus requests are generated by masters and responses are supplied by slaves.
All signals on the request bus are outgoing from the master and input by the slave. All signals on the response bus are output by the slave and input by the master.
Requests are placed on the bus as single-cycle events. If the slave is not ready it will have rty response signal asserted and the master must retry the request.
When the slave receives a request, it may place a response on the response bus as a single cycle event. Typically the system has buffers which collect the slave responses so that a common bus may be used by multiple slaves.
The response buffer system can collect responses from multiple slaves simultaneously, which are then stored temporarily and arbitrated onto an output response bus. Note that the responses may not be in the same order as the requests, although they often are.
The slave may respond when it chooses. That could be the next cycle after a request for a simple slave, or it could be several cycles after a request is received for a more complex slave. There is no wait or ready signal for use with responses; it is not needed.
There is a bus transaction id associated with every request and responses. The master must match-up the responses to the requests.
There is a signal call 'stall' which is not currently implemented, but may be used to stall the bus if needed.
Requests from a master often traverse a tree-like structure to reach slaves. Typically there are bridges in the SoC to distribute the master's requests and maintain performance. The bridges may also perform bus width conversions.
For instance the instruction cache has typically a 128-bit read port and may interface to 128-bit wide memories in the system. While some slaves are 32-bit requiring 32-bit accesses.
Currently the bridges do not break apart a 128-bit access and convert it to multiple 32-bit accesses. Instead a 32-bit access request must be placed on the 128-bit bus.

The bus is relatively fast when compared to a synchronous bus in a complex system. A master may for instance place a burst of accesses on the bus then wait for responses. While waiting for responses another different master may place a burst on the bus.
A synchronous bus would need to wait for an acknowledgement before proceeding. In a complex system with several bridges that may occupy the entire bus for a number of cycles meaning it could not be used by other devices. A goal of FTA bus is higher bus
utilization.

There is a collection of structures implementing request and response portions of the bus. There are separate structures for
each bus size. I found it easier to use than parameterizing the structures. 

fta_cmd_request128_t  <- this structure is the request bus for a 128-bit bus
fta_cmd_response128_t <- this structure is the response bus for a 128-bit bus

## Requests
There are numerous signals on the request bus. Signals that are not used should be de-asserted.
Some hi-lights:
'cyc' indicates a valid cycle. The slave and bus bridges will only process requests with 'cyc' asserted. Anything else will be ignored.
'tid' is the transaction id for the request. It has three sub-fields for the core number, channel number, and transaction id.
'cmd' indicates the operation to perform. This is typically a 'LOAD' or 'STORE', but it may be other operations useful for atomic memory operations.
'vadr' is the virtual address used to place the data.
'padr' is the physical address used to place the data. 'vadr' and 'padr' may be the same if virtual addresses are not used.
'data1' is the first data element to be transferred for a storage type operation.
'data2' is a second data element to be transferred for atomic operations like 'CAS'.
'sel' indicates which portions of the data field are valid. There is a select line for each byte of the data field.

## Responses
All responses, including MSI interrupts and other error responses, must have the 'ack' signal of the response bus asserted. This is how the master knows there is a response to be processed.
Responses indicate a successful transfer using the 'err' signal. A value of 'OKAY' indicates the transfer was successful. Other values indicate a bus error or interrupt.
Responses should place read data on the 'dat' field of the bus.
The 'tid' field of a response must match the 'tid' field of the request.
The 'adr' field of the response should reflect the physical address of the request. This is to aid a master in sorting responses.
For store operations (CLASSIC bus cycles), there does not need to be a response.

## MSI - Message Signalled Interrupts
FTA bus provides for message signalled interrupts.
There is a response code ('IRQ') on the response bus to support message signalled interrupts. A slave may place an IRQ message on a response bus (the 'err' field) to interrupt the master.
The bus master monitors responses for IRQ requests. The slave places an 8-bit error code, 4-bit interrupt priority and target core information on the data response signals. 
