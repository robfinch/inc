# FTA Bus
(c) 2005 Robert Finch

## Overview
FTA bus is an asynchronous bus used by the author (Finitron) mainly as a system-on-chip bus to interface bus masters and slaves together.

## History
It evolved from the 'WISHBONE' bus over time as a desire for better bus performance in a complex SoC.

## Structure
The bus is split into request and response parts. Bus requests are generated by masters and responses are supplied by slaves.
All signals on the request bus are outgoing from the master and input by the slave. All signals on the response bus are output by the slave and input by the master.
Requests are placed on the bus as single-cycle events. If the slave is not ready it will have rty response signal asserted and the master must retry the request.
When the slave receives a request, it may place a response on the response bus as a single cycle event. Typically the system has buffers which collect the slave responses so that a common bus may be used by multiple slaves.
The response buffer system can collect responses from multiple slaves simultaneously, which are then stored temporarily and arbitrated onto an output response bus. Note that the responses may not be in the same order as the requests, although they often are.
The slave may respond when it chooses. That could be the next cycle after a request for a simple slave, or it could be several cycles after a request is received for a more complex slave. There is no wait or ready signal for use with responses; it is not needed.
There is a bus transaction id associated with every request and responses. The master must match-up the responses to the requests.
There is a signal call 'stall' which is not currently implemented, but may be used to stall the bus if needed.
Requests from a master often traverse a tree-like structure to reach slaves. Typically there are bridges in the SoC to distribute the master's requests and maintain performance. The bridges may also perform bus width conversions.
For instance the instruction cache has typically a 256-bit read port and may interface to 256-bit wide memories in the system. While some slaves are 32-bit requiring 32-bit accesses.
Currently the bridges do not break apart a 256-bit access and convert it to multiple 32-bit accesses. Instead a 32-bit access request must be placed on the 256-bit bus.

The bus is relatively fast when compared to a synchronous bus in a complex system. A master may for instance place a burst of accesses on the bus then wait for responses. While waiting for responses another different master may place a burst on the bus.
A synchronous bus would need to wait for an acknowledgement before proceeding. In a complex system with several bridges that may occupy the entire bus for a number of cycles meaning it could not be used by other devices. A goal of FTA bus is higher bus
utilization.

There is a collection of structures implementing request and response portions of the bus. There are separate structures for
each bus size. The author found it easier to use than parameterizing the structures. 

fta_cmd_request128_t  <- this structure is the request bus for a 128-bit bus
fta_cmd_response128_t <- this structure is the response bus for a 128-bit bus

## Requests
There are numerous signals on the request bus. Signals that are not used should be de-asserted.
Some hi-lights:
|Signal|Description|
|------|------------------------------------------------------------------------------------------------------------------------------------------------------|
|'cyc'| indicates a valid cycle. The slave and bus bridges will only process requests with 'cyc' asserted. Anything else will be ignored.|
|'tid'| is the transaction id for the request. It has three sub-fields for the core number, channel number, and transaction id.|
|'cmd'| indicates the operation to perform. This is typically a 'LOAD' or 'STORE', but it may be other operations useful for atomic memory operations.|
|'vadr'| is the virtual address used to place the data.|
|'padr'| is the physical address used to place the data. 'vadr' and 'padr' may be the same if virtual addresses are not used.|
|'data1'| is the first data element to be transferred for a storage type operation.|
|'data2'| is a second data element to be transferred for atomic operations like 'CAS'.|
|'sel' |indicates which portions of the data field are valid. There is a select line for each byte of the data field.|

## Responses
All responses, including MSI interrupts and other error responses, must have the 'ack' signal of the response bus asserted. This is how the master knows there is a response to be processed.
|Signal|Description|
|------|------------------------------------------------------------------------------------------|
|'ack'|This signal indicates a valid response.|
|'err'|Responses indicate a successful transfer using the 'err' signal. A value of 'OKAY' indicates the transfer was successful. Other values indicate a bus error or interrupt.|
|'dat'|Responses should place read data on the 'dat' field of the bus.|
|'tid'|The 'tid' field of a response must match the 'tid' field of the request.|
|'adr'|The 'adr' field of the response should reflect the physical address of the request. This is to aid a master in sorting responses.|

For store operations (CLASSIC bus cycles), there does not need to be a response.

## MSI - Message Signalled Interrupts
FTA bus provides for message signaled interrupts. A MSI interrupt transfers the required information to an interrupt controller without needing a request for it. This trims cycle time off an interrupt request. A devices slave response bus is used to signal the interrupt, this means that the device does not need a bus mastering port. The interrupt controller snoops the CPU response bus for IRQ requests.
Up to 62 interrupt controllers may be targeted to process interrupts messages. The interrupt table located in the controller specifies which of 62 target CPU cores to notify of the interrupt. Therefore about 3800 CPU cores may easily be used for interrupt processing.
There is a response code ('IRQ') on the response bus to support message signaled interrupts. A slave may place an IRQ message on a response bus (the 'err' field) to interrupt the master.
### Response Bus with MSI
|Signal|Description|
|------|------------------------------------------------------------------------------------------|
|'ack'|This signal indicates a valid response; should be high for MSI|
|'err'|value = IRQ|
|'dat'|Interrupt message data. Typically 32-bits|
|'tid'|The coreno should reflect the target core servicing the interrupt. This is an interrupt controller number.|
|'adr'|The 'adr' field of the response indicates the bus/device/function generating the interrupt.|

### tid field breakdown for MSI
|Bit|Description|
|-----|-------------------|
|0...5| interrupt priority|
|6...6| reserved|
|7...12| target irq controller number - a number of 63 indicates a broadcast interrupt. zero is not used|

### dat field breakdown for MSI
|Bit|Description|
|------|------------------------|
|0...10| interrupt vector number|
|11...13| reserved|
|14...15| operating mode required|
|16...31| data to be placed in interrupt table|

### adr field breakdown for MSI
|Bit|Description|
|-----|---------|
|0...2| FTA func|
|3...7| FTA device|
|8...15| FTA bus|
|16...28| FTA segment|
|29...31| index for required software stack|

The interrupt controller monitors responses for IRQ requests. The slave places interrupt information on the response signals as outlined above.

## Component Discovery
FTA bus is still evolving. Used in association with the bus is a device or component discovery black-box (DDBB). The device discovery black-box allows a device's address and other associated controls to be programmatically controlled.
Ths DDBB is modelled after the same ideas behind popular device discovery, search for "pci" on the web. The discovery component is called a black-box component because it is just plugged into any device needing it without modification.
The DDBB's themselves are allocated in a 512MB memory mapped region. They follow the device/bus/function addressing. Each DDBB is allocated it's own 8kB block of memory. The first 1kB is allocated for registers, the last 7kB may contain a ROM image associated with the device.
|Regno|Description|
|-----|----------------------|
| 00  | Device and Vendor IDs|
| 04  | command and status reg|
| 08  | BAR0 base address register #0|
| 0C  | BAR1 base address register #1|
| 10  | BAR2 base address register #2|
| 14  | BAR3 base address register #3|
| 18  | BAR4 base address register #4|
| 1C	| BAR bits 32 to 63|
| 40  | IRQ info #0 MSI "dat" field|
| 44  | IRQ info #0 MSI "adr" field|
| 48  | IRQ info #0 MSI "tid" field|
| 4C  | reserved|
| ... | IRQ info #1 to 2
| 70  | IRQ info #3 MSI "dat" field|
| 74  | IRQ info #3 MSI "adr" field|
| 78  | IRQ info #3 MSI "tid" field|
| 7C  | reserved|

### command reg
|Bits|Description|
|----|-----------|
|10|interrupt enable|

### status reg
|Bit|Description|
|---|-----------|
|3|interrupt present|

Note that all BAR's share the same upper 32-bits.

## Examples
There is a very simple example of use of the FTA bus to drive LEDs called 'ledport_fta32.sv' in the Utility cores repository.
For a more complex example, see "random_fta32.sv".
Many of the more recent cores requiring a bus use the FTA bus.
